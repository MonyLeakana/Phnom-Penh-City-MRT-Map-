<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Station & Edge Editor</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #ffffff;
    }
    #app {
      padding: 16px 24px;
    }

    /* Toolbar pills */
    #toolbar {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-left: 40px;
      margin-bottom: 12px;
    }
    button {
      padding: 8px 18px;
      border-radius: 999px;
      border: 2px solid #222;
      background: #fff;
      font-size: 14px;
      cursor: pointer;
    }
    button:hover { background: #f2f2f2; }
    #status {
      margin-left: auto;
      font-size: 0.9rem;
      color: #555;
    }

    /* Map frame */
    #map-frame {
      margin: 0 40px;
      border: 2px solid #000;
      height: 75vh;
    }
    #map {
      width: 100%;
      height: 100%;
    }

    /* Bottom row: distance left, confirm button right */
    #bottom-row {
      margin-top: 18px;
      margin-left: 40px;
      margin-right: 40px;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
    }
    #distance-panel {
      font-size: 18px;
      line-height: 1.4;
    }
    #distance-panel strong { display: block; }
    #total-distance-value {
      font-weight: 600;
    }

    .edge-label {
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #aaa;
      padding: 0 3px;
      border-radius: 3px;
      font-size: 10px;
      color: #222;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="toolbar">
      <button id="undo-btn">Undo Station</button>
      <button id="erase-node-btn">Erase Station</button>
      <button id="erase-edge-btn">Erase Edge</button>
      <button id="auto-edge-btn">Auto Edge</button>
      <button id="show-mst-btn">Show MST Only</button>
      <span id="status">Loading...</span>
    </div>

    <div id="map-frame">
      <div id="map"></div>
    </div>

    <div id="bottom-row">
      <div id="distance-panel">
        <strong>Total Distance (MST):</strong>
        <span id="total-distance-value">N/A</span>
      </div>
      <button id="confirm-base-btn">Confirm Base Map</button>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // ---------- Map setup ----------
    const initialLat = 11.5564;  // Phnom Penh-ish
    const initialLng = 104.9282;

    const map = L.map("map").setView([initialLat, initialLng], 12);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const statusEl = document.getElementById("status");
    const totalDistanceEl = document.getElementById("total-distance-value");
    function setStatus(msg) { statusEl.textContent = msg; }

    // ---------- Local state ----------
    const stations = new Map();   // id -> {id, lat, lng}
    const markers  = new Map();   // id -> Leaflet circleMarker
    const polylines = new Map();  // edgeId -> Leaflet polyline
    const edgesData = new Map();  // edgeId -> edge object

    let selectedStationId = null;
    let eraseEdgeMode = false;
    let eraseNodeMode = false;
    let mstOnlyMode = false;

    const NODE_STYLE = {
      radius: 5,
      color: "#111",
      fillColor: "#fff",
      fillOpacity: 1,
      weight: 1
    };
    const DEFAULT_EDGE_STYLE = {
      weight: 3,
      color: "#0074D9",
      opacity: 0.85
    };
    const MST_EDGE_STYLE = {
      weight: 4,
      color: "red",
      opacity: 0.95
    };

    // ---------- Helper: clear / redraw ----------
    function clearAllLayers() {
      markers.forEach(m => map.removeLayer(m));
      polylines.forEach(l => map.removeLayer(l));
      markers.clear();
      polylines.clear();
      stations.clear();
      edgesData.clear();
    }

    function addMarkerFromPoint(point) {
      stations.set(point.id, point);

      const marker = L.circleMarker([point.lat, point.lng], NODE_STYLE).addTo(map);
      marker.bindPopup(
        `ID: ${point.id}<br>` +
        `Lat: ${point.lat.toFixed(5)}<br>` +
        `Lng: ${point.lng.toFixed(5)}`
      );

      marker.on("click", function (e) {
        L.DomEvent.stopPropagation(e);
        handleMarkerClick(point.id);
      });

      markers.set(point.id, marker);
    }

    function addEdgeFromData(edge) {
      const s = stations.get(edge.from);
      const t = stations.get(edge.to);
      if (!s || !t) return;

      edgesData.set(edge.id, edge);

      const line = L.polyline(
        [
          [s.lat, s.lng],
          [t.lat, t.lng],
        ],
        DEFAULT_EDGE_STYLE
      ).addTo(map);

      const distanceText = `${edge.distance_km.toFixed(2)} km`;
      line.bindTooltip(distanceText, {
        permanent: true,
        direction: "center",
        className: "edge-label"
      });

      line.on("click", function (e) {
        L.DomEvent.stopPropagation(e);
        if (!eraseEdgeMode) return;
        deleteEdge(edge.id);
      });

      polylines.set(edge.id, line);
    }

    function redrawFromData(nodes, edges) {
      clearAllLayers();
      nodes.forEach(addMarkerFromPoint);
      edges.forEach(addEdgeFromData);
      // After delete, MST distance is outdated
      totalDistanceEl.textContent = "N/A";
    }

    function resetEdgeStyles() {
      for (const [, line] of polylines.entries()) {
        line.setStyle(DEFAULT_EDGE_STYLE);
      }
    }

    function showAllEdges() {
      for (const [, line] of polylines.entries()) {
        line.addTo(map);
      }
    }

    function hideAllEdges() {
      for (const [, line] of polylines.entries()) {
        map.removeLayer(line);
      }
    }

    function highlightMSTEdges(mstEdges) {
      mstEdges.forEach(edge => {
        const line = polylines.get(edge.id);
        if (line) {
          line.setStyle(MST_EDGE_STYLE);
        }
      });
    }

    // ---------- Node / edge handlers ----------
    function handleMarkerClick(stationId) {
      if (eraseNodeMode) {
        deleteNode(stationId);
        return;
      }

      if (eraseEdgeMode) {
        setStatus("Edge erase mode active. Click an edge to delete it.");
        return;
      }

      if (selectedStationId === null) {
        selectedStationId = stationId;
        setStatus(
          `Selected station #${stationId}. Click another station to connect, ` +
          `or click on the map to add & connect a new station.`
        );
      } else if (selectedStationId === stationId) {
        selectedStationId = null;
        setStatus("Selection cleared.");
      } else {
        const src = selectedStationId;
        const tgt = stationId;
        selectedStationId = null;
        createEdge(src, tgt);
      }
    }

    function createEdge(fromId, toId) {
      mstOnlyMode = false;
      showAllEdges();
      resetEdgeStyles();
      totalDistanceEl.textContent = "N/A";

      setStatus("Saving edge...");
      fetch("/add_edge", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ from: fromId, to: toId }),
      })
        .then((res) => {
          if (!res.ok) {
            throw new Error("Failed to save edge");
          }
          return res.json();
        })
        .then((edge) => {
          addEdgeFromData(edge);
          setStatus(
            `Edge #${edge.id} added: ${edge.from} ↔ ${edge.to} (${edge.distance_km.toFixed(2)} km)`
          );
        })
        .catch((err) => {
          console.error(err);
          setStatus("Error saving edge");
        });
    }

    function deleteEdge(edgeId) {
      mstOnlyMode = false;
      showAllEdges();
      resetEdgeStyles();
      totalDistanceEl.textContent = "N/A";

      setStatus(`Deleting edge #${edgeId}...`);
      fetch("/delete_edge", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ edge_id: edgeId }),
      })
        .then(res => {
          if (!res.ok) {
            throw new Error("Failed to delete edge");
          }
          return res.json();
        })
        .then(data => {
          const removed = data.removed;
          const line = polylines.get(removed.id);
          if (line) {
            map.removeLayer(line);
            polylines.delete(removed.id);
          }
          edgesData.delete(removed.id);
          setStatus(
            `Deleted edge #${removed.id} (${removed.from} ↔ ${removed.to}).`
          );
        })
        .catch(err => {
          console.error(err);
          setStatus("Error deleting edge");
        });
    }

    function deleteNode(nodeId) {
      mstOnlyMode = false;
      showAllEdges();
      resetEdgeStyles();
      totalDistanceEl.textContent = "N/A";

      setStatus(`Deleting station #${nodeId}...`);
      fetch("/delete_node", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ node_id: nodeId }),
      })
        .then(res => {
          if (!res.ok) throw new Error("Failed to delete station");
          return res.json();
        })
        .then(data => {
          if (data.status !== "ok") throw new Error("Delete station error");
          const nodes = data.nodes || [];
          const edges = data.edges || [];
          redrawFromData(nodes, edges);
          eraseNodeMode = false;
          selectedStationId = null;
          setStatus(
            `Deleted station #${data.removed_node_id} and `
            + `${data.removed_edges_count} connected edge(s).`
          );
        })
        .catch(err => {
          console.error(err);
          setStatus("Error deleting station");
        });
    }

    // ---------- Initial load ----------
    fetch("/points")
      .then((res) => res.json())
      .then((points) => {
        points.forEach(addMarkerFromPoint);
        setStatus(`Loaded ${points.length} stations. Click map to add more.`);
        return fetch("/edges");
      })
      .then((res) => res.json())
      .then((edges) => {
        edges.forEach(addEdgeFromData);
        if (edges.length > 0) {
          setStatus(
            `Loaded ${stations.size} stations and ${edges.length} edges.`
          );
        }
      })
      .catch((err) => {
        console.error(err);
        setStatus("Failed to load initial data");
      });

    // ---------- Map click: add new station ----------
    map.on("click", function (e) {
      if (eraseEdgeMode || eraseNodeMode) {
        setStatus(
          eraseNodeMode
            ? "Station erase mode active. Click a station marker to delete it."
            : "Edge erase mode active. Click an edge to delete it."
        );
        return;
      }

      mstOnlyMode = false;
      showAllEdges();
      resetEdgeStyles();
      totalDistanceEl.textContent = "N/A";

      const lat = e.latlng.lat;
      const lng = e.latlng.lng;

      setStatus("Saving station...");

      fetch("/add_point", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ lat, lng }),
      })
        .then((res) => {
          if (!res.ok) {
            throw new Error("Failed to save station");
          }
          return res.json();
        })
        .then((point) => {
          addMarkerFromPoint(point);
          setStatus(
            `Added station #${point.id} at (${lat.toFixed(
              5
            )}, ${lng.toFixed(5)}).`
          );

          if (selectedStationId !== null) {
            const src = selectedStationId;
            selectedStationId = null;
            createEdge(src, point.id);
          }
        })
        .catch((err) => {
          console.error(err);
          setStatus("Error saving station");
        });
    });

    // ---------- Undo last station ----------
    document.getElementById("undo-btn").addEventListener("click", function () {
      mstOnlyMode = false;
      eraseEdgeMode = false;
      eraseNodeMode = false;
      showAllEdges();
      resetEdgeStyles();
      totalDistanceEl.textContent = "N/A";

      setStatus("Undoing last station...");

      fetch("/undo", { method: "POST" })
        .then((res) => {
          if (!res.ok) {
            if (res.status === 400) {
              throw new Error("No stations to undo.");
            }
            throw new Error("Undo failed.");
          }
          return res.json();
        })
        .then((data) => {
          const removed = data.removed;
          const removedEdges = data.removed_edges || [];

          const marker = markers.get(removed.id);
          if (marker) {
            map.removeLayer(marker);
            markers.delete(removed.id);
          }
          stations.delete(removed.id);

          removedEdges.forEach((edge) => {
            const poly = polylines.get(edge.id);
            if (poly) {
              map.removeLayer(poly);
              polylines.delete(edge.id);
            }
            edgesData.delete(edge.id);
          });

          selectedStationId = null;
          setStatus(
            `Removed station #${removed.id} and ${removedEdges.length} edge(s).`
          );
        })
        .catch((err) => {
          console.error(err);
          setStatus(err.message);
        });
    });

    // ---------- MST button (Show MST Only toggle) ----------
    document.getElementById("show-mst-btn").addEventListener("click", function () {
      if (!mstOnlyMode) {
        setStatus("Computing MST and showing only MST edges...");
        fetch("/mst", { method: "POST" })
          .then((res) => {
            if (!res.ok) {
              throw new Error("Failed to compute MST");
            }
            return res.json();
          })
          .then((data) => {
            if (data.status !== "ok") {
              throw new Error("MST computation error");
            }
            const mstEdges = data.mst_edges || [];

            hideAllEdges();
            mstEdges.forEach(edge => {
              const line = polylines.get(edge.id);
              if (line) {
                line.setStyle(MST_EDGE_STYLE);
                line.addTo(map);
              }
            });

            mstOnlyMode = true;

            const total = data.total_distance_km ?? 0;
            const isSpanning = data.is_spanning ? "" : " (graph may be disconnected)";
            totalDistanceEl.textContent = total.toFixed(2) + " km";
            setStatus(
              `MST only view: ${mstEdges.length} edges, total length ${total.toFixed(2)} km${isSpanning}`
            );
          })
          .catch((err) => {
            console.error(err);
            setStatus("Error computing MST");
          });
      } else {
        mstOnlyMode = false;
        showAllEdges();
        resetEdgeStyles();
        setStatus("Showing all edges again.");
        // keep last MST distance in text, or reset if you prefer
      }
    });

    // ---------- Erase edge mode toggle ----------
    document.getElementById("erase-edge-btn").addEventListener("click", function () {
      mstOnlyMode = false;
      showAllEdges();
      resetEdgeStyles();
      totalDistanceEl.textContent = "N/A";

      eraseEdgeMode = !eraseEdgeMode;
      eraseNodeMode = false;
      selectedStationId = null;
      if (eraseEdgeMode) {
        setStatus("Edge erase mode ON. Click an edge to delete it.");
      } else {
        setStatus("Edge erase mode OFF.");
      }
    });

    // ---------- Erase station mode toggle ----------
    document.getElementById("erase-node-btn").addEventListener("click", function () {
      mstOnlyMode = false;
      showAllEdges();
      resetEdgeStyles();
      totalDistanceEl.textContent = "N/A";

      eraseNodeMode = !eraseNodeMode;
      eraseEdgeMode = false;
      selectedStationId = null;
      if (eraseNodeMode) {
        setStatus("Station erase mode ON. Click a station marker to delete it.");
      } else {
        setStatus("Station erase mode OFF.");
      }
    });

    // ---------- Auto edges (> 1 km) ----------
    document.getElementById("auto-edge-btn").addEventListener("click", function () {
      mstOnlyMode = false;
      showAllEdges();
      resetEdgeStyles();
      totalDistanceEl.textContent = "N/A";

      setStatus("Generating auto edges (> 1 km)...");
      fetch("/auto_edges", { method: "POST" })
        .then(res => {
          if (!res.ok) {
            throw new Error("Failed to auto-generate edges");
          }
          return res.json();
        })
        .then(data => {
          const added = data.added || 0;
          const newEdges = data.edges || [];
          newEdges.forEach(addEdgeFromData);
          setStatus(`Auto edges added: ${added} new edge(s) (> 1 km).`);
        })
        .catch(err => {
          console.error(err);
          setStatus("Error generating auto edges");
        });
    });

    // ---------- Confirm Base Map ----------
    document.getElementById("confirm-base-btn").addEventListener("click", function () {
      setStatus("Confirming base map (saving MST as base)...");
      fetch("/confirm_base_map", { method: "POST" })
        .then(res => {
          if (!res.ok) throw new Error("Failed to confirm base map");
          return res.json();
        })
        .then(data => {
          if (data.status !== "ok") throw new Error("Error in base map confirmation");
          // Optionally update MST total
          const total = data.total_distance_km ?? 0;
          totalDistanceEl.textContent = total.toFixed(2) + " km";
          setStatus("Base map confirmed. Redirecting to /basemap...");
          window.location.href = "/basemap";
        })
        .catch(err => {
          console.error(err);
          setStatus("Error confirming base map");
        });
    });
  </script>
</body>
</html>
